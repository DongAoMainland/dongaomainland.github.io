<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python之正则表达式</title>
      <link href="/2019/10/01/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/10/01/python%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>现在的数据处理，特别在互联网领域中，很大部分是字符类数据的处理。而该类数据一个主要处理就是：字符或字符串的匹配处理。我们知道这种匹配处理正是正规则表达式的用武之地。同样在Python的标准库中，有re模块正是用于字符串匹配发现。<br>这里我们并不打算对正则表达式进行太细的讨论，正则表达式中规则多，各种操作千变万化，我们也记不清。这里主要讲讲python中正则表达式的主体流程，细的匹配规则，可以查找下类似下面的文档或手册：<br>[Python正则表达式指南]<a href="https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="noopener">https://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html</a></p><a id="more"></a><h1 id="简单的匹配"><a href="#简单的匹配" class="headerlink" title="简单的匹配"></a>简单的匹配</h1><p>假设我们要在“dog find the cat”，这句话中寻找是否存在”cat”，或者”bird”。首先我们可能会想到使用常规的方法来实现这个功能，参见下面的样例代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line"># 匹配字符串</span><br><span class="line">pattern1 = &apos;cat&apos;</span><br><span class="line">pattern2 = &apos;bird&apos;</span><br><span class="line">string1 = &quot;dog find the cat&quot;</span><br><span class="line">print(pattern1 in string1)</span><br><span class="line">print(pattern2 in string1)</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>从结果来看，是可以找到指定的字符串的。<br>但我们通常不会这样进行字符串的匹配，而是会使用python的标准模块re，调用该模块的search()方法，匹配到则返回相应的object，如没有匹配到，则返回none。<br>具体参见样例代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line"># 通过正则表达式匹配字符串</span><br><span class="line">pattern1 = &apos;cat&apos;</span><br><span class="line">pattern2 = &apos;bird&apos;</span><br><span class="line">string1 = &quot;dog find the cat&quot;</span><br><span class="line">print(re.search(pattern1, string1))</span><br><span class="line">print(re.search(pattern2, string1))</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(13, 16), match=&apos;cat&apos;&gt;</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>从匹配到的对象里，我们可以看到匹配的字符串，以及字符串在句子中的位置</p><h1 id="灵活的匹配"><a href="#灵活的匹配" class="headerlink" title="灵活的匹配"></a>灵活的匹配</h1><p>如果要找到潜在的多个可能的文字，可以使用“[]”将要匹配的所有字符囊括起来，比如[ab]，就是要的字符可以是“a”，也可以是“b”。但是我们需要在创建的匹配模式pattern前，加上一个”r”，用于表示接下来的字符串”…”，不是普通的字符串，而是正则表达式。具体参见样例代码3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line"># 通过正则表达式匹配字符串</span><br><span class="line">pattern1 = r&quot;d[io]g&quot;</span><br><span class="line">string1 = &quot;dog find the cat&quot;</span><br><span class="line">print(re.search(pattern1, string1))</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 3), match=&apos;dog&apos;&gt;</span><br></pre></td></tr></table></figure><h1 id="重复的匹配"><a href="#重复的匹配" class="headerlink" title="重复的匹配"></a>重复的匹配</h1><p>如果想让某个规则重复使用，也是可实现的，实现的方式有很多种:</p><ul><li><p>*: 规则重复0次或多次；</p></li><li><p>+: 规则重复1次或多次；</p></li><li><ul><li>{n, m}: 规则重复n至m次；</li></ul></li><li><p>{n}: 规则重复n次。<br>参见样例代码4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line"># *: 下面的&apos;b&apos;字符，要被命中了0~n次</span><br><span class="line">print(re.search(r&quot;ab*&quot;, &quot;a&quot;)) # 被命中了0次</span><br><span class="line">print(re.search(r&quot;ab*&quot;, &quot;abbbbbbbb&quot;)) # 被命中了8次</span><br><span class="line"></span><br><span class="line"># +: 下面的&apos;b&apos;字符，要被命中了1~n次</span><br><span class="line">print(re.search(r&quot;ab+&quot;, &quot;a&quot;)) # 被命中了0次</span><br><span class="line">print(re.search(r&quot;ab+&quot;, &quot;abbbbbbbb&quot;)) # 被命中了8次</span><br><span class="line"></span><br><span class="line"># &#123;n, m&#125;: 下面的&apos;b&apos;字符，要被命中了n~m次</span><br><span class="line">print(re.search(r&quot;ab&#123;2,7&#125;&quot;, &quot;a&quot;)) # 被命中了0次</span><br><span class="line">print(re.search(r&quot;ab&#123;9,12&#125;&quot;, &quot;abbbbbbbb&quot;)) # 被命中了8次</span><br></pre></td></tr></table></figure></li></ul><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(0, 1), match=&apos;a&apos;&gt;</span><br><span class="line">&lt;re.Match object; span=(0, 9), match=&apos;abbbbbbbb&apos;&gt;</span><br><span class="line">None</span><br><span class="line">&lt;re.Match object; span=(0, 9), match=&apos;abbbbbbbb&apos;&gt;</span><br><span class="line">None</span><br><span class="line">None</span><br></pre></td></tr></table></figure><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>经常，我们还需要为找到的内容进行分组。通过分组，可以轻松定位到所找到的内容。分组是由()来实现的。下面来看样例代码5：在(\d+)这个组里，找到的是一些数字，而在(.+)这个组里，则可找到”Date: “后面所有内容。使用match.group()方法，会返回所有组的内容，而如果给.group()方法加上一数字，则定位到那个具体组的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line">match = re.search(r&quot;(\d+), Date: (.+)&quot;, &quot;ID: 021523, Date: Feb/12/2017&quot;)</span><br><span class="line">print(match.group())                   # 021523, Date: Feb/12/2017</span><br><span class="line">print(match.group(1))                  # 021523</span><br><span class="line">print(match.group(2))                  # Date: Feb/12/2017</span><br></pre></td></tr></table></figure><p>当数据很多，且组很多时，光用数字是很难找到想要的组的。此时，如果有个名字做索引，则会让这个查找方便许多。为此，正则表达式中提供了”?P&lt;名字&gt;”给组定义索引名字的途径。具体参见样例代码6：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line">match = re.search(r&quot;(?P&lt;id&gt;\d+), Date: (?P&lt;date&gt;.+)&quot;, &quot;ID: 021523, Date: Feb/12/2017&quot;)</span><br><span class="line">print(match.group(&apos;id&apos;))                # 021523</span><br><span class="line">print(match.group(&apos;date&apos;))              # Date: Feb/12/201</span><br></pre></td></tr></table></figure><h1 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h1><p>前面的匹配，都是只找到最开始匹配的第一项，如想要找到所有匹配的项，则请调用findall()方法。来看样例代码7：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line"># findall</span><br><span class="line">print(re.findall(r&quot;r[ua]n&quot;, &quot;run ran ren&quot;))    # [&apos;run&apos;, &apos;ran&apos;]</span><br><span class="line"></span><br><span class="line"># | : 表示或的关系</span><br><span class="line">print(re.findall(r&quot;(run|ran)&quot;, &quot;run ran ren&quot;)) # [&apos;run&apos;, &apos;ran&apos;]</span><br></pre></td></tr></table></figure><p>代码7执行的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;run&apos;, &apos;ran&apos;]</span><br><span class="line">[&apos;run&apos;, &apos;ran&apos;]</span><br></pre></td></tr></table></figure><h1 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h1><p>在文本数据的查找处理中，常伴随着要替换查找到的字符。string.replace()方法也有替换字符串的功能，它这是在已字符串的前提下实现的，而使用正规则表达式库re.sub()，可以实现更灵活的字符串匹配，与替换。参见样例代码8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line">print(re.sub(r&quot;finds&quot;, &quot;catches&quot;, &quot;dog finds the cat&quot;))</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog catches the cat</span><br></pre></td></tr></table></figure><h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>字符串处理常需要将串根据特定的字符进行分割，比如”,”，而正则表达式也提供了split()方法，来实现该功能。参见样例代码9：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line">print(re.split(r&quot;[,;\.]&quot;, &quot;a;b,c.d;e&quot;))</span><br></pre></td></tr></table></figure><p>代码9的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure><h1 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h1><p>文本处理是相当复杂的，有时写完或写正确一个正则表达式，并不容易。为此re模块提供了compile()方法，可以对编写好的正则表达式，进行编译，编译得到的对象，可以被重复利用，后面可以直接使用该对象，来进行相应字符或字符串的匹配与处理。参见样例代码10：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">import re # 引入re模块</span><br><span class="line"></span><br><span class="line">compiled_re = re.compile(r&quot;r[ua]n&quot;)</span><br><span class="line">print(compiled_re.search(&quot;dog ran to cat&quot;))</span><br></pre></td></tr></table></figure><p>代码10执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(4, 7), match=&apos;ran&apos;&gt;</span><br></pre></td></tr></table></figure><p>至此，关于python相关的基础知识就先补充到这里。后面在算法学习过程中，碰到python其它的问题时，我们再对它们进一步讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之pickle保存</title>
      <link href="/2019/09/29/python%E4%B9%8Bpickle%E4%BF%9D%E5%AD%98/"/>
      <url>/2019/09/29/python%E4%B9%8Bpickle%E4%BF%9D%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>数据除了要保存在内存，有时，还需要进行序列化，保存到磁盘上。python标准库中的pickle模块，就提供了文件的压缩、保存与提取功能。</p><a id="more"></a><h1 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a>数据保存</h1><p>下面样例代码1，使用pickle模块，对字典数据进行了压缩并保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import pickle</span><br><span class="line">aDict = &#123;&apos;da&apos;:1,2:[3,4,5], &apos;23&apos;:&#123;6:7, &apos;c&apos;:&apos;bad guy&apos;&#125;&#125;</span><br><span class="line"></span><br><span class="line"># 打开一文件，指向一后缀名为.pickle的文件，该文件就是一个pickle文件对象</span><br><span class="line">file = open(&apos;adict.pickle&apos;,&apos;wb&apos;) # wd表示拥有该文件的进行二机制数据的写操作权限</span><br><span class="line">pickle.dump(aDict, file)</span><br></pre></td></tr></table></figure><p>代码1执行后，会在程序目录下生成文件adict.picle：<br>![adict.pickle如不存在，会新生成]/images/assets/ailearning/picklesave.png</p><h1 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h1><p>提取保存在pickle文件中的数据，就是以读的方式，打开文件，并调用pickle模块的load()方法，对数据进行加载即可。具体参见样例代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import pickle</span><br><span class="line"></span><br><span class="line"># 打开一文件，指向一后缀名为.pickle的文件，该文件就是一个pickle文件对象</span><br><span class="line">with open(&apos;adict.pickle&apos;,&apos;rb&apos;) as file: # rd表示拥有该文件的进行二机制数据的读操作权限</span><br><span class="line">aDict = pickle.load(file)</span><br><span class="line"></span><br><span class="line">print(aDict)</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;da&apos;: 1, 2: [3, 4, 5], &apos;23&apos;: &#123;6: 7, &apos;c&apos;: &apos;bad guy&apos;&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多进程</title>
      <link href="/2019/09/28/python%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <url>/2019/09/28/python%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>threading让程序更灵活，但在数据处理效率上，并不能提高太多。而multiprocessing，可以充分利用当下计算机多处理器的特性，可以让任务执行分摊至各个处理器，从而成倍地提高效率。</p><a id="more"></a><h1 id="增加进程"><a href="#增加进程" class="headerlink" title="增加进程"></a>增加进程</h1><p>下面则是简单一个例子，将在主进程中，再增加一个子进程。具体看下面的样例代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数</span><br><span class="line">def job(a,d):</span><br><span class="line">    print(&apos;一个新的进程运行了！&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;: # 如此声明，则确保下面的程序体属于主程序对象个体</span><br><span class="line">print(&apos;主程序运行着&apos;)</span><br><span class="line"># 这里直接使用系统类Process来创建进程对象，没有去新建一个子类。（线程对象也可采用类似方法创建）</span><br><span class="line">p1 = mp.Process(target=job,args=(1,2)) # 创建子进程对象</span><br><span class="line">p1.start()</span><br><span class="line">p1.join()</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主程序运行着</span><br><span class="line">一个新的进程运行了！</span><br></pre></td></tr></table></figure><p>这里主要是看看子进程与主进程的并发执行，与多线程的效率对比，在下面进一步详述。</p><h1 id="数据处理进程将数据输入输出到Queue"><a href="#数据处理进程将数据输入输出到Queue" class="headerlink" title="数据处理进程将数据输入输出到Queue"></a>数据处理进程将数据输入输出到Queue</h1><p>像多线程一样，多进程执行体函数也是没有返回值的（该函数在后台运行，如果有返回值，运行完了由谁接收？），所以要使用Queue来存储多个进程的运算结果。<br>来看样例代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数</span><br><span class="line">def job(q,no):</span><br><span class="line">    res=0</span><br><span class="line">    if(no == 1):</span><br><span class="line">    num = 100</span><br><span class="line">    else:</span><br><span class="line">    num = 1000</span><br><span class="line">    for i in range(num):</span><br><span class="line">        res+=i+i**2+i**3</span><br><span class="line">    q.put(res)    # 进程将处理结果放入队列，队列的同步原语，确保了队列中元素的唯一性</span><br><span class="line"></span><br><span class="line">if __name__==&apos;__main__&apos;:</span><br><span class="line">    q = mp.Queue()</span><br><span class="line">    p1 = mp.Process(target=job,args=(q,1)) # args是参数列表，当只有一个值时，其后应加&quot;,&quot;,表示可迭代，否则执行会报错</span><br><span class="line">    p2 = mp.Process(target=job,args=(q,2))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    </span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    res1 = q.get()</span><br><span class="line">    res2 = q.get()</span><br><span class="line">    print(res1)</span><br><span class="line">    print(res2)</span><br><span class="line">    print(res1+res2)</span><br></pre></td></tr></table></figure><p>代码执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">24835800 # 先进先出队列的第一个元素被取出</span><br><span class="line">249833583000 # 先进先出队列的第二个元素被取出</span><br><span class="line">249858418800</span><br></pre></td></tr></table></figure><p><em>注：我们并不能确定Queue中的元素，是由哪个进程放的。哪个进程先被执行队列的存放，那它就先获得访问的权利</em></p><h1 id="多线程与多进程间的效率对比"><a href="#多线程与多进程间的效率对比" class="headerlink" title="多线程与多进程间的效率对比"></a>多线程与多进程间的效率对比</h1><p>下面是本次学习最为重要的内容：比较多进程、多线程与单线程这3种情况下，对同样任务所消耗的时间。<br>下面是样例代码3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line">import threading as td</span><br><span class="line">import time # 该模块与时间相关，这里用来计算各方式下所耗时间</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数，该函数将进行较大规模的数据处理</span><br><span class="line">def job(q):</span><br><span class="line">    res = 0</span><br><span class="line">    for i in range(1000000):</span><br><span class="line">        res += i + i**2 + i**3</span><br><span class="line">    q.put(res) # queue</span><br><span class="line"></span><br><span class="line"># 采用多进程的方式，调用job函数，进行大规模数据处理</span><br><span class="line">def multiProcess():</span><br><span class="line">    q = mp.Queue()</span><br><span class="line">    p1 = mp.Process(target=job, args=(q,))</span><br><span class="line">    p2 = mp.Process(target=job, args=(q,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    res1 = q.get()</span><br><span class="line">    res2 = q.get()</span><br><span class="line">    print(&apos;multiprocess:&apos;,res1 + res2)</span><br><span class="line"></span><br><span class="line"># 采用多线程的方式，调用job()函数，进行大规模的数据处理</span><br><span class="line">def multiThread():</span><br><span class="line">    q = mp.Queue() # thread可放入process同样的queue中</span><br><span class="line">    t1 = td.Thread(target=job, args=(q,))</span><br><span class="line">    t2 = td.Thread(target=job, args=(q,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    res1 = q.get()</span><br><span class="line">    res2 = q.get()</span><br><span class="line">    print(&apos;multithread:&apos;, res1 + res2)</span><br><span class="line">    </span><br><span class="line"># 采用普通函数的方式，进行同样规模的数据处理</span><br><span class="line">def normal():</span><br><span class="line">    res = 0</span><br><span class="line">    for _ in range(2): # 前面的多进程与多线程都有2个，为了达到同规模的计算，这里也就循环了2次</span><br><span class="line">        for i in range(1000000):</span><br><span class="line">            res += i + i**2 + i**3</span><br><span class="line">    print(&apos;normal:&apos;, res)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    st = time.time()</span><br><span class="line">    normal()</span><br><span class="line">    st1 = time.time()</span><br><span class="line">    print(&apos;normal time:&apos;, st1 - st)</span><br><span class="line">    multiThread()</span><br><span class="line">    st2 = time.time()</span><br><span class="line">    print(&apos;multithread time:&apos;, st2 - st1)</span><br><span class="line">    multiProcess()</span><br><span class="line">    print(&apos;multiprocess time:&apos;, time.time() - st2)</span><br></pre></td></tr></table></figure><p>代码3执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">normal: 499999666667166666000000</span><br><span class="line">normal time: 1.5309014320373535</span><br><span class="line">multithread: 499999666667166666000000</span><br><span class="line">multithread time: 1.6715011596679688</span><br><span class="line">multiprocess: 499999666667166666000000</span><br><span class="line">multiprocess time: 0.9295573234558105</span><br></pre></td></tr></table></figure><p>从结果来看，效率的高低排序为：多进程 &gt; 普通 &gt; 多线程。</p><h1 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h1><p>通过进程池，可以解决进程执行体函数没有返回值等问题。具体先来看样例代码4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数，该函数将进行较大规模的数据处理</span><br><span class="line">def job(x):</span><br><span class="line">    return x * x </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 采用多进程的方式，调用job函数，进行大规模数据处理</span><br><span class="line">def multiProcess():</span><br><span class="line">    # 定义一个Pool对象</span><br><span class="line">    pool = mp.Pool()</span><br><span class="line">    # 有了该对象后，就可将进程池与进程执行体函数映射起来。我们往该池里丢数据，池子会执行该函数，并返回值。有返回值，是Pool与process最大的不同。</span><br><span class="line">    res = pool.map(job, range(10))</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    multiProcess()</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>当然，在定义进程池时，可以指定要用的CPU核数，这样就可以指定进程池的进程数。这里就不讲例子了，大家可以自己编写体会。<br>下面要讲的是一个替代map()的进程输出方式。该方式叫apply_async()，不同于map的输入数据是数组类型，也就是可接收多条数据的输入，它接收的值是可迭代的，这就意味着，其传入值后面要加”,”，也意味着，它一次只能传进一个值，也就是一次取一条数据放到一个CPU核中处理。另外返回值不能直接返回，只能通过get()方法获取。<br>来看样例代码5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数，该函数将进行较大规模的数据处理</span><br><span class="line">def job(x):</span><br><span class="line">    return x * x </span><br><span class="line"></span><br><span class="line"># 采用多进程的方式，调用job函数，进行大规模数据处理</span><br><span class="line">def multiProcess():</span><br><span class="line">    # 定义一个Pool对象</span><br><span class="line">    pool = mp.Pool()</span><br><span class="line">    # 有了该对象后，就可将进程池与进程执行体函数映射起来。我们往该池里丢数据，池子会执行该函数，并返回值。有返回值，是Pool与process最大的不同。</span><br><span class="line">    res = pool.map(job, range(10))</span><br><span class="line">    print(res)</span><br><span class="line">    res = pool.apply_async(job,(2,)) # 采用迭代异步方式调用进程池中的进程进行数据处理</span><br><span class="line">    print(res.get())</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    multiProcess()</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>如果强硬给apply_async()传入多个值，是会报错了。实在要让它能处理多条数据，并输出多条结果，可以采用迭代的途径来实现。请参见样例代码6：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数，该函数将进行较大规模的数据处理</span><br><span class="line">def job(x):</span><br><span class="line">    return x * x </span><br><span class="line"></span><br><span class="line"># 采用多进程的方式，调用job函数，进行大规模数据处理</span><br><span class="line">def multiProcess():</span><br><span class="line">    pool = mp.Pool() </span><br><span class="line">    res = pool.map(job, range(10))</span><br><span class="line">    print(res)</span><br><span class="line">    res = pool.apply_async(job, (2,))</span><br><span class="line">    # 用get获得结果</span><br><span class="line">    print(res.get())</span><br><span class="line">    # 迭代器，i=0时apply一次，i=1时apply一次等等</span><br><span class="line">    multi_res = [pool.apply_async(job, (i,)) for i in range(10)]</span><br><span class="line">    # 从迭代器中取出</span><br><span class="line">    print([res.get() for res in multi_res])</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    multiProcess()</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] # map输出</span><br><span class="line">4</span><br><span class="line">[0, 1, 4, 9, 16, 25, 36, 49, 64, 81] # apply_async多输出</span><br></pre></td></tr></table></figure><h1 id="共享内存与进程锁"><a href="#共享内存与进程锁" class="headerlink" title="共享内存与进程锁"></a>共享内存与进程锁</h1><p>数据处理过程中，多个进程间可能需要交流，此时自然就会用到共享内存。<br>multiprocessing中实现了一个Value类，其对象就是将数据存储在一个共享的内存表中。<br>另外，multiprocessing模块中，还实现了一个Array类，用来在共享内存中存放一维数组。<br>不管Value对象，还是Array对象定义时，除了要指定数据外，还要指定数据的类型。可用的数据类型参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">| Type code | C Type             | Python Type       | Minimum size in bytes |</span><br><span class="line">| --------- | ------------------ | ----------------- | --------------------- |</span><br><span class="line">| `&apos;b&apos;`     | signed char        | int               | 1                     |</span><br><span class="line">| `&apos;B&apos;`     | unsigned char      | int               | 1                     |</span><br><span class="line">| `&apos;u&apos;`     | Py_UNICODE         | Unicode character | 2                     |</span><br><span class="line">| `&apos;h&apos;`     | signed short       | int               | 2                     |</span><br><span class="line">| `&apos;H&apos;`     | unsigned short     | int               | 2                     |</span><br><span class="line">| `&apos;i&apos;`     | signed int         | int               | 2                     |</span><br><span class="line">| `&apos;I&apos;`     | unsigned int       | int               | 2                     |</span><br><span class="line">| `&apos;l&apos;`     | signed long        | int               | 4                     |</span><br><span class="line">| `&apos;L&apos;`     | unsigned long      | int               | 4                     |</span><br><span class="line">| `&apos;q&apos;`     | signed long long   | int               | 8                     |</span><br><span class="line">| `&apos;Q&apos;`     | unsigned long long | int               | 8                     |</span><br><span class="line">| `&apos;f&apos;`     | float              | float             | 4                     |</span><br><span class="line">| `&apos;d&apos;`     | double             | float             | 8                     |</span><br></pre></td></tr></table></figure><p>当多进程同时访问共享内存对象时，没有进程锁，整个程序的执行是会乱套的。下面样例代码7就是没使用进程锁的情形：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数，该函数将进行较大规模的数据处理</span><br><span class="line">def job(v, num): # v是共享内存对象</span><br><span class="line">    for _ in range(5):</span><br><span class="line">    time.sleep(0.1)  # 让进程暂停0.1秒，以便其它进程获得共享内存的访问权，从而让输出效果更明显</span><br><span class="line">    v.value += num # 对共享内存对象的值，进行访问操作</span><br><span class="line">    print(v.value, end = &quot;\r\n&quot;)</span><br><span class="line">    #print(v.value, end=&quot;&quot;)</span><br><span class="line"></span><br><span class="line"># 采用多进程的方式，调用job函数，进行大规模数据处理</span><br><span class="line">def multiProcess():</span><br><span class="line">    v = mp.Value(&apos;i&apos;, 0) # 定义共享变量</span><br><span class="line">    p1 = mp.Process(target=job, args=(v,1))</span><br><span class="line">    p2 = mp.Process(target=job, args=(v,3)) # 两个进程使用不同的num，从而方便查看两个进程是如何抢夺共享内存的访问权</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    multiProcess()</span><br></pre></td></tr></table></figure><p>代码执行情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>从结果来看，两个进程交替对共享内存的数据，进行着修改，这种抢占，会让两进程对共享内存中的数据都无所适从。<br>为此，我们对共享内存的访问一定要加上进程锁。参见样例代码8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import multiprocessing as mp</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 定义进程执行体函数，该函数将进行较大规模的数据处理</span><br><span class="line">def job(v, num, lock): # v是共享内存对象</span><br><span class="line">    lock.acquire() # 上锁</span><br><span class="line">    for _ in range(5):</span><br><span class="line">    time.sleep(0.1)  # 让进程暂停0.1秒，以便其它进程获得共享内存的访问权，从而让输出效果更明显</span><br><span class="line">    v.value += num # 对共享内存对象的值，进行访问操作</span><br><span class="line">    print(v.value, end = &quot;\r\n&quot;)</span><br><span class="line">    #print(v.value, end=&quot;&quot;)</span><br><span class="line">    lock.release() # 释放锁</span><br><span class="line"></span><br><span class="line"># 采用多进程的方式，调用job函数，进行大规模数据处理</span><br><span class="line">def multiProcess():</span><br><span class="line">    lock = mp.Lock() # 定义一个进程锁</span><br><span class="line">    v = mp.Value(&apos;i&apos;, 0) # 定义共享对象</span><br><span class="line">    p1 = mp.Process(target=job, args=(v,1,lock))</span><br><span class="line">    p2 = mp.Process(target=job, args=(v,3,lock)) # 两个进程使用不同的num，从而方便查看两个进程是如何抢夺共享内存的访问权</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    multiProcess()</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">11</span><br><span class="line">14</span><br><span class="line">17</span><br><span class="line">20</span><br></pre></td></tr></table></figure><p>从结果来看，虽然进程会进入睡眠，让出CPU执行权，但由于它先拿住了进程锁，这样，在它访问完共享内存前，进程2是无法访问共享内存的，因此结果是2个进程对共享内存的顺序处理结果。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中的多线程</title>
      <link href="/2019/09/27/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/09/27/python%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>基于大数据的人工智能算法，都面临着效率的问题。此时懂计算机的人，一般都会想到多进程与多线程技术。今天就先讲讲多线程。<br>多线程Threading，就是让一个程序拥有多条执行路径，同时可以处理多个任务。而一般的程序，采用的是顺序执行模式，只能一条条代码顺序执行，而Threading技术，就让程序好像同时拥有了多个分身，使得程序更加灵活，功能更加强大。</p><a id="more"></a><h1 id="Threading模块"><a href="#Threading模块" class="headerlink" title="Threading模块"></a>Threading模块</h1><p>Python3标准库里有两个与线程相关的库：</p><ul><li>_thread；</li><li>threading。<br>其中，_thread提供低级别、原始线程，以及一个简单的锁，它的功能相对有限，因此，这里我们主要讲threading。<br>threading除了包含_thread模块中的所有方法外，还提供以下方法：</li><li>threading.currentThread()：返回当前的线程变量；</li><li>threading.enumerate()：返回一个正在运行的所有线程的list，不包括启动前和终止后的线程；</li><li>threading.activeCount()：返回正在运行的线程数量，这个值应等于len(threading.enumerate())。<br>除上的方法外，同样提供了以下Thread类方法：</li><li>run()：线程执行体方法；</li><li>start()：启动线程；</li><li>join([time])：等待至线程停止；</li><li>isAlive()：返回线程是否活动着状态；</li><li>getName()：返回线程名；</li><li>setName()：设置线程名。</li></ul><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>可以从threading.Thread类继承出一个新的子类，并通过子类实例一个线程对象，再调用该对象的start()方法，来启动该线程，线程一启动，其实就会调用该线程的run()方法。具体请看样例代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">exitFlag = 0</span><br><span class="line"></span><br><span class="line">class aThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, counter):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开始线程：&quot; + self.name)</span><br><span class="line">        print_time(self.name, self.counter, 5)</span><br><span class="line">        print (&quot;退出线程：&quot; + self.name)</span><br><span class="line"></span><br><span class="line">def print_time(threadName, delay, counter):</span><br><span class="line">    while counter:</span><br><span class="line">        if exitFlag:</span><br><span class="line">            threadName.exit()</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= 1</span><br><span class="line"></span><br><span class="line"># 创建新线程</span><br><span class="line">thread1 = aThread(1, &quot;Thread-1&quot;, 1)</span><br><span class="line">thread2 = aThread(2, &quot;Thread-2&quot;, 2)</span><br><span class="line"></span><br><span class="line"># 开启新线程</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br></pre></td></tr></table></figure><p>代码1执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">开始线程：Thread-1</span><br><span class="line">开始线程：Thread-2</span><br><span class="line">Thread-1: Fri Sep 27 15:33:22 2019</span><br><span class="line">Thread-2: Fri Sep 27 15:33:23 2019</span><br><span class="line">Thread-1: Fri Sep 27 15:33:23 2019</span><br><span class="line">Thread-1: Fri Sep 27 15:33:24 2019</span><br><span class="line">Thread-2: Fri Sep 27 15:33:25 2019</span><br><span class="line">Thread-1: Fri Sep 27 15:33:25 2019</span><br><span class="line">Thread-1: Fri Sep 27 15:33:26 2019</span><br><span class="line">退出线程：Thread-1</span><br><span class="line">Thread-2: Fri Sep 27 15:33:27 2019</span><br><span class="line">Thread-2: Fri Sep 27 15:33:29 2019</span><br><span class="line">Thread-2: Fri Sep 27 15:33:31 2019</span><br><span class="line">退出线程：Thread-2</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><p>从结果可以看到，两个子线程是在交差异步执行的。</p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>多线程之间可能会有交互，这就会存在同步的需求。比如，多个线程都要对某个数据进行修改，对各线程而言，如没有同步机制，就会得到不可预料的结果。因此threading提供了Lock和RLock来实现简单的线程同步，通过它们的acquire方法和release方法，来确保在某一时刻，只会有一个线程操作这些共享的数据。<br>下面样例代码2，通过它，我们进一步深入理解基于锁机制，实现多线程之间的同步。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class aThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, counter):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.counter = counter</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开启线程： &quot; + self.name)</span><br><span class="line">        # 获取锁，用于线程同步</span><br><span class="line">        threadLock.acquire()</span><br><span class="line">        print_time(self.name, self.counter, 3)</span><br><span class="line">        # 释放锁，开启下一个线程</span><br><span class="line">        threadLock.release()</span><br><span class="line"></span><br><span class="line">def print_time(threadName, delay, counter):</span><br><span class="line">    while counter:</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))</span><br><span class="line">        counter -= 1</span><br><span class="line"></span><br><span class="line">threadLock = threading.Lock()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"># 创建新线程</span><br><span class="line">thread1 = aThread(1, &quot;Thread-1&quot;, 1)</span><br><span class="line">thread2 = aThread(2, &quot;Thread-2&quot;, 2)</span><br><span class="line"></span><br><span class="line"># 开启新线程</span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"># 添加线程到线程列表</span><br><span class="line">threads.append(thread1)</span><br><span class="line">threads.append(thread2)</span><br><span class="line"></span><br><span class="line"># 等待所有线程完成</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br></pre></td></tr></table></figure><p>代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">开启线程： Thread-1</span><br><span class="line">开启线程： Thread-2</span><br><span class="line">Thread-1: Fri Sep 27 19:10:11 2019</span><br><span class="line">Thread-1: Fri Sep 27 19:10:12 2019</span><br><span class="line">Thread-1: Fri Sep 27 19:10:13 2019</span><br><span class="line">Thread-2: Fri Sep 27 19:10:15 2019</span><br><span class="line">Thread-2: Fri Sep 27 19:10:17 2019</span><br><span class="line">Thread-2: Fri Sep 27 19:10:19 2019</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><p>从结果来看，两个线程在锁的同步控制下，就不再是乱序执行。</p><h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><p>线程在同时执行时，处理的数据会有主次，因此它们要按一定优先次序排列。<br>而python标准库中有个queue模块，它提供了同步的，线程安全的队列类，包括FIFO队列Queue，LIFO队列LifoQueue，以及PriorityQueue。<br>这些队列都实现了锁原语，能够在多线程中直接使用，来实现线程间的同步；当队列没有数据时，get()方法就会被阻塞，而当队列已满，则put()方法会被阻塞。<br>Queue模块中的常用方法：</p><ul><li>Queue.qsize() 返回队列的大小；</li><li>Queue.empty() 如果队列为空，返回True，反之False；</li><li>Queue.full() 如果队列满，返回True，反之False；</li><li>Queue.get([block[,timeout]]) 获取队列，timeout等待时间</li><li>Queue.get_nowait()</li><li>Queue.put()</li><li>Queue.put_nowait()</li><li>Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号</li><li>Queue.join() 实际上意味着等到队列为空，再执行别的操作。</li></ul><p>具体参见样例代码3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import queue</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">exitFlag = 0</span><br><span class="line"></span><br><span class="line">class aThread (threading.Thread):</span><br><span class="line">    def __init__(self, threadID, name, q):</span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.q = q</span><br><span class="line">    def run(self):</span><br><span class="line">        print (&quot;开启线程：&quot; + self.name)</span><br><span class="line">        process_data(self.name, self.q)</span><br><span class="line">        print (&quot;退出线程：&quot; + self.name)</span><br><span class="line"></span><br><span class="line">def process_data(threadName, q):</span><br><span class="line">    while not exitFlag:</span><br><span class="line">        queueLock.acquire()</span><br><span class="line">        if not workQueue.empty():</span><br><span class="line">            data = q.get()</span><br><span class="line">            queueLock.release()</span><br><span class="line">            print (&quot;%s processing %s&quot; % (threadName, data))</span><br><span class="line">        else:</span><br><span class="line">            queueLock.release()</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line">threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]</span><br><span class="line">nameList = [&apos;one&apos;,&apos;two&apos;,&apos;three&apos;,&apos;four&apos;,&apos;five&apos;]</span><br><span class="line">queueLock = threading.Lock()</span><br><span class="line">workQueue = queue.PriorityQueue()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">threadID = 1</span><br><span class="line"></span><br><span class="line"># 创建新线程</span><br><span class="line">for tName in threadList:</span><br><span class="line">    thread = aThread(threadID, tName, workQueue)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    threadID += 1</span><br><span class="line"></span><br><span class="line"># 填充队列</span><br><span class="line">num = 5</span><br><span class="line">queueLock.acquire()</span><br><span class="line">for word in nameList:</span><br><span class="line">    workQueue.put(num, word)</span><br><span class="line">    num -= 1</span><br><span class="line">    if(num == 2):</span><br><span class="line">    num = -1</span><br><span class="line">    if(num == -2):</span><br><span class="line">    num = 31</span><br><span class="line">    </span><br><span class="line">queueLock.release()</span><br><span class="line"></span><br><span class="line"># 等待队列清空</span><br><span class="line">while not workQueue.empty():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 通知线程是时候退出</span><br><span class="line">exitFlag = 1</span><br><span class="line"></span><br><span class="line"># 等待所有线程完成</span><br><span class="line">for t in threads:</span><br><span class="line">    t.join()</span><br><span class="line">print (&quot;退出主线程&quot;)</span><br></pre></td></tr></table></figure><p>代码3执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">开启线程：Thread-1</span><br><span class="line">开启线程：Thread-2</span><br><span class="line">开启线程：Thread-3</span><br><span class="line">Thread-3 processing -1</span><br><span class="line">Thread-2 processing 3</span><br><span class="line">Thread-1 processing 4</span><br><span class="line">Thread-3 processing 5</span><br><span class="line">Thread-1 processing 31</span><br><span class="line">退出线程：Thread-3</span><br><span class="line">退出线程：Thread-2</span><br><span class="line">退出线程：Thread-1</span><br><span class="line">退出主线程</span><br></pre></td></tr></table></figure><p>从结果来看，存放在优先级队列的数据，按优先级数排列，其中该数越小，值就越大。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python一深一浅两拷贝</title>
      <link href="/2019/09/25/python%E4%B8%80%E6%B7%B1%E4%B8%80%E6%B5%85%E4%B8%A4%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/09/25/python%E4%B8%80%E6%B7%B1%E4%B8%80%E6%B5%85%E4%B8%A4%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>前面讲过，人工智能算法牵涉到大量数据处理，其中肯定会有大量的数据迁移，特别在集群环境中，这种数据的拷贝动作会更多。而python拷贝有一深一浅之说，它们之间是有差别的，不弄清楚，很容易就会出错。这里就讲讲python的深拷贝与浅拷贝。</p><a id="more"></a><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p>我们知道，python是种纯面向对象的语言，它把一切都当作对象，包括算法要处理的数据。而对象是具体的，因此都有唯一性，为了标识这种唯一性，因此都会有一个id值。而对于Python的解释器来讲，id就是该对象在内存的“地址”。下面我们通过样例代码1来进一步理解它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import copy # copy是python标准库进行数据深、浅拷贝的模块</span><br><span class="line">listA = [1,2,3]</span><br><span class="line">listB = listA</span><br><span class="line"></span><br><span class="line">print(id(listA))</span><br><span class="line">print(id(listB))</span><br><span class="line">print(id(listA) == id(listB))</span><br><span class="line"></span><br><span class="line">listB[0] = 111111 # 修改listB中第一个元素的值，会导致listA的对应元素的值也改变</span><br><span class="line">print(listA, listB)</span><br></pre></td></tr></table></figure><p>代码1执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2428878144136</span><br><span class="line">2428878144136</span><br><span class="line">True # 说明两个对象的id是相等的</span><br><span class="line">[111111, 2, 3] [111111, 2, 3] # 说明listA与listB两个变量指向的是同一个对象</span><br></pre></td></tr></table></figure><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>有了前面关于id的知识，再来理解浅拷贝就容易了。浅拷贝只是拷贝对象的内容。看样例代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import copy # copy是python标准库进行数据深、浅拷贝的模块</span><br><span class="line">listA = [1,2,3]</span><br><span class="line">listC = copy.copy(listA) # 拷贝对象listA的内容</span><br><span class="line"></span><br><span class="line">print(id(listA))</span><br><span class="line">print(id(listC))</span><br><span class="line">print(id(listA) == id(listC))</span><br><span class="line"></span><br><span class="line">listC[0] = 111111 # 修改lisC中第一个元素的值，listA的对应元素的值不改变</span><br><span class="line">print(listA, listC)</span><br></pre></td></tr></table></figure><p>代码2执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2076272050504</span><br><span class="line">2076271544264</span><br><span class="line">False # 说明两个对象的id不相同</span><br><span class="line">[1, 2, 3] [111111, 2, 3] # 说明listC的修改，只会影响变量listC的值，listA没影响</span><br></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>浅拷贝对于对象的内部对象或元素，仍然是直接引用，而深拷贝，除了对对象本身进行拷贝，对其内部对象不再是地址的引用，也会是内容的拷贝。请看样例代码3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">import copy # copy是python标准库进行数据深、浅拷贝的模块</span><br><span class="line">listA = [1,2,[3,4]] # 第三个值为列表，其值为[3,4]，它是个内部元素</span><br><span class="line">listC = copy.copy(listA) # 浅拷贝，对于listA内部元素[3,4]，拷贝的是它的引用</span><br><span class="line"></span><br><span class="line">print(id(listA) == id(listC))</span><br><span class="line">print(id(listA[2]) == id(listC[2]))</span><br><span class="line">listA[2][0] = 3333 # 修改listA中内部元素的第一个值</span><br><span class="line">print(listC) # 内部元素对应的值也应以身试法</span><br><span class="line"></span><br><span class="line"># copy.deepcopy()</span><br><span class="line">listD = copy.deepcopy(listA) # listD对listA进行了深拷贝</span><br><span class="line">listA[2][0] = 444</span><br><span class="line">print(listD)</span><br></pre></td></tr></table></figure><p>代码3执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">False#listC与listA已不是同一个对象</span><br><span class="line">True #listC内部对象[3,4]，与listA内部对象[3,4], ID是一样的，就是同一个对象</span><br><span class="line">[1, 2, [3333, 4]] # listC内部对象的值随listA中内部对象值的修改而修改</span><br><span class="line">[1, 2, [3333, 4]] # listD内部对象的值并没有随listA中内部对象值的修改而修改</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python几个常用的数据处理机制</title>
      <link href="/2019/09/24/python%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/09/24/python%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>数据是人工智能算法中的生产材料，其中会有大量与数据打交道的地方，其中会常用到3个与数据处理相关的机制。这里就讲讲如何通过它们，来实现数据的组拼、快捷地处理，以及与处理函数的映射等。</p><a id="more"></a><h1 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h1><p>该函数用来实现同维度列表之间的数据组拼。它的组拼是基于列向的。具体请看下面的样例代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">listA = [1,2,3]</span><br><span class="line">listB = [4,5,6]</span><br><span class="line">aB = zip(listA, listB)</span><br><span class="line">print(aB)#python3为了节省内存，将listA与listB组拼得到了一个对象，这里打印的是该对象所在的地址</span><br><span class="line">print(list(aB)) #通过将对象转化为列表，就可看到数据的组成形式了</span><br><span class="line"></span><br><span class="line"># 遍历组拼的数据对象，并进行处理</span><br><span class="line">for i,j in zip(listA,listB):</span><br><span class="line">print(i*2, j*2)</span><br></pre></td></tr></table></figure><p>代码1执行输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;zip object at 0x000001E049698708&gt;</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">2 8</span><br><span class="line">4 10</span><br><span class="line">6 12</span><br></pre></td></tr></table></figure><h1 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h1><p>它其实就是匿名函数，没有函数名，聚焦在函数执行语句上，对于语句简单时，这种随写随丢的方式特别合适，也与数据转换的情境相吻合。<br>具体请看下面的样例代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">x = int(input(&apos;请输入数字x：&apos;)) #这里通过int将您输入的字符转换成整数</span><br><span class="line">y = int(input(&apos;请输入数字y：&apos;))</span><br><span class="line"></span><br><span class="line">z = lambda i,j: i + j</span><br><span class="line">print(z(x, y))</span><br></pre></td></tr></table></figure><p>代码2执行输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入数字x：7</span><br><span class="line">请输入数字y：9</span><br><span class="line">16</span><br></pre></td></tr></table></figure><h1 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h1><p>其作用就是把数据与函数绑定在一起，把指定的数据交由指定的函数去处理。<br>具体请看下面的样例代码3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">def function(x, y):</span><br><span class="line">return (x + y)</span><br><span class="line"></span><br><span class="line">listA = list(map(function, [2], [4]))</span><br><span class="line">print(listA)</span><br><span class="line"></span><br><span class="line">listB = list(map(function, [2,3], [4,5]))</span><br><span class="line">print(listB)</span><br></pre></td></tr></table></figure><p>代码3执行输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[6]</span><br><span class="line">[6, 8]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错误处理Try</title>
      <link href="/2019/09/23/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86Try/"/>
      <url>/2019/09/23/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86Try/</url>
      
        <content type="html"><![CDATA[<p>程序中常会有系统资源的请求与访问，比如对某文件发出请求，但此时系统不一定确保有此资源，或资源你有访问的权限让你访问，因此程序无法保障这些语句都能够成功获得响应或执行，也就是会发生除正常情况之外的情形—异常。这些异常不加处理的话，就会导致程序的业务逻辑运转不灵。于是，python如Java语言一样，有错误处理的机制，它的语法格式如下：try: … except … as …:</p><a id="more"></a><p>下面是样例代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">file = open(&apos;error.txt&apos;, &apos;r&apos;)# 由于文件不存在，会出错</span><br><span class="line">except Exception as e: # 把错误存放在e中</span><br><span class="line">print(e)</span><br></pre></td></tr></table></figure><p>下面是代码1的执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Errno 2] No such file or directory: &apos;error.txt&apos;</span><br></pre></td></tr></table></figure><p>事实上，我们的异常处理可能不仅会打出错误是什么，往往会让用户针对错误，进行对应的操作。<br>因此，修改代码1，得到样例代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">file = open(&apos;error.txt&apos;, &apos;r&apos;)# 由于文件不存在，会出错</span><br><span class="line">except Exception as e: # 把错误存放在e中</span><br><span class="line">print(e)</span><br><span class="line">handleException = input(&apos;你想要创建这个新的文件吗？&apos;)</span><br><span class="line">if handleException == &apos;y&apos;:</span><br><span class="line">file = open(&apos;error.txt&apos;, &apos;w&apos;)</span><br><span class="line">else:</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">file.write(&apos;ssss&apos;)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>样例代码的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Errno 2] No such file or directory: &apos;error.txt&apos;</span><br><span class="line">你想要创建这个新的文件吗？y</span><br></pre></td></tr></table></figure><p>在程序当前执行的目录下，我们将看到新增加了文件，error.txt，而且文中的内容如下：<br><img src="/images/assets/ailearning/error.jpg" alt="error.txx的内容"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python循环退出</title>
      <link href="/2019/09/23/Python%E5%BE%AA%E7%8E%AF%E9%80%80%E5%87%BA/"/>
      <url>/2019/09/23/Python%E5%BE%AA%E7%8E%AF%E9%80%80%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>任何编程语言的初学者，都会面临一个窘境：程序跑着，退不出来。也是循环代码段，进入了常说的死循环。退出循环，语法上常有3种情形。掌握它们，我们基于Python的程序，就可进可出了。</p><a id="more"></a><h1 id="通过循环条件语句False"><a href="#通过循环条件语句False" class="headerlink" title="通过循环条件语句False"></a>通过循环条件语句False</h1><p>循环体执行前，会通过一个条件语句，来判断是否需要执行循环体：<br>    - 1、    如果条件语句为True，则执行；<br>    - 2、    如果条件语句为False，则跳过循环体，执行其后的语句。<br>下面是样例代码1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">condition = True</span><br><span class="line">while condition:</span><br><span class="line">changeFactor = input(&apos;请输入：&apos;)</span><br><span class="line">if changeFactor == &apos;1&apos;:</span><br><span class="line">condition = False</span><br><span class="line">else:</span><br><span class="line">pass</span><br><span class="line">print(&apos;循环结束！&apos;)</span><br></pre></td></tr></table></figure><p>下面是代码1执行结果的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入：0</span><br><span class="line">请输入：2</span><br><span class="line">请输入：1</span><br><span class="line">循环结束！</span><br></pre></td></tr></table></figure><hr><h1 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h1><p>其实，我们在循环体内如果发现情况不对，有些情况下，不用继续执行循环体中的其它语句，可以直接从体内跳出。<br>下面是在样例代码1上修改得到的代码2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">changeFactor = input(&apos;请输入：&apos;)</span><br><span class="line">if changeFactor == &apos;1&apos;:</span><br><span class="line">break</span><br><span class="line">else:</span><br><span class="line">pass</span><br><span class="line">print(&apos;我们还在循环体内&apos;)</span><br><span class="line">print(&apos;循环结束！&apos;)</span><br></pre></td></tr></table></figure><p>下面是代码2执行结果的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入：2</span><br><span class="line">我们还在循环体内</span><br><span class="line">请输入：4</span><br><span class="line">我们还在循环体内</span><br><span class="line">请输入：1</span><br><span class="line">循环结束！</span><br></pre></td></tr></table></figure><hr><h1 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h1><p>该语句也是从循环体内退出，但它是从此次循环退出，不会转而去执行循环体外的下一条语句，而是继续下一次的循环，也就是跳转到循环体的开头，继续执行。初学者，特别容易把它与break语句混淆，常写写代码就好了，实在脑子知短路，不妨到这篇博文看看好了。<br>下面是在代码2上修改得到的代码3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">changeFactor = input(&apos;请输入：&apos;)</span><br><span class="line">if changeFactor == &apos;1&apos;:</span><br><span class="line">continue</span><br><span class="line">else:</span><br><span class="line">pass</span><br><span class="line">print(&apos;我们还在循环体内&apos;)</span><br><span class="line">print(&apos;循环结束！&apos;)</span><br></pre></td></tr></table></figure><p>下面是代码3执行结果的输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请输入：2</span><br><span class="line">我们还在循环体内</span><br><span class="line">请输入：4</span><br><span class="line">我们还在循环体内</span><br><span class="line">请输入：1# 没有打印输出“我们还在循环体内”</span><br><span class="line">请输入：</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零基础 </tag>
            
            <tag> Python语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能教程清单</title>
      <link href="/2019/09/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%95%99%E7%A8%8B%E6%B8%85%E5%8D%95/"/>
      <url>/2019/09/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%95%99%E7%A8%8B%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>这里列出人工智能算法教学的内容清单。内容按目录顺序给出，也基本排出了我们教学内容的计划。顺着这个计划去学习，哪怕你是零基础，只要锲而不舍，勤动手，相信您也能够成为一个AI算法的砖家。</p><a id="more"></a><h1 id="零基础准备篇"><a href="#零基础准备篇" class="headerlink" title="零基础准备篇"></a>零基础准备篇</h1><h2 id="Python基础语法"><a href="#Python基础语法" class="headerlink" title="Python基础语法"></a>Python基础语法</h2><p>参见：<br>    - <a href="https://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-tutorial.html</a><br>    - <a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a><br>前者是针对python2的，后者是针对python3的。我们教程与样例，是基于python3的，你就看后一个就可以。当然，您想进一步深入了解与掌握，也可私下与我们再沟通。</p><h2 id="Numpy与Pandas"><a href="#Numpy与Pandas" class="headerlink" title="Numpy与Pandas"></a>Numpy与Pandas</h2><p>人工智能算法，其实是数据价值发掘的算法，特别是大数据处理的算法。因此，我们有必要对数据的组织形式，以及创建样例测试数据，应有所了解。</p><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><h2 id="数据到底长什么样子，数据处理后又是什么样子，就是靠这个画图库来展现给大家的。"><a href="#数据到底长什么样子，数据处理后又是什么样子，就是靠这个画图库来展现给大家的。" class="headerlink" title="数据到底长什么样子，数据处理后又是什么样子，就是靠这个画图库来展现给大家的。"></a>数据到底长什么样子，数据处理后又是什么样子，就是靠这个画图库来展现给大家的。</h2><h1 id="机器学习篇"><a href="#机器学习篇" class="headerlink" title="机器学习篇"></a>机器学习篇</h1><p>也就是Machine Learning（ML）。由于这已不是我们当下人工智能领域流行的，所以我们不用把它当重点。<br>如果您还想进一步了解与掌握，可参见：<br>    - <a href="https://www.cnblogs.com/pinard/category/894692.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/category/894692.html</a><br>    - 或私下与我们沟通</p><h2 id="机器学习介绍"><a href="#机器学习介绍" class="headerlink" title="机器学习介绍"></a>机器学习介绍</h2><p>就是讲讲什么是机器学习。</p><h2 id="SKlearn"><a href="#SKlearn" class="headerlink" title="SKlearn"></a>SKlearn</h2><p>这是个机器学习中常用的库。里面有许多ML相关的，成熟的算法。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="选择学习"><a href="#选择学习" class="headerlink" title="选择学习"></a>选择学习</h3><h3 id="通用学习"><a href="#通用学习" class="headerlink" title="通用学习"></a>通用学习</h3><h3 id="数据相关的库"><a href="#数据相关的库" class="headerlink" title="数据相关的库"></a>数据相关的库</h3><h3 id="常用属性与功能"><a href="#常用属性与功能" class="headerlink" title="常用属性与功能"></a>常用属性与功能</h3><h3 id="正规化"><a href="#正规化" class="headerlink" title="正规化"></a>正规化</h3><h3 id="神经网络检验"><a href="#神经网络检验" class="headerlink" title="神经网络检验"></a>神经网络检验</h3><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><h3 id="模型保存"><a href="#模型保存" class="headerlink" title="模型保存"></a>模型保存</h3><hr><h1 id="神经网络篇"><a href="#神经网络篇" class="headerlink" title="神经网络篇"></a>神经网络篇</h1><p>ML对应最多一个词，就是DL（Deep Learning）深度学习。但从学习这门技术的角度，我们更愿意从神经网络出发，因为深度学习就是深度的神经网络。</p><h2 id="人工神经网络与生物神经网络区别"><a href="#人工神经网络与生物神经网络区别" class="headerlink" title="人工神经网络与生物神经网络区别"></a>人工神经网络与生物神经网络区别</h2><p>神经网络是仿生物的神经网络而诞生的，它能取代生物神经网络吗？</p><h2 id="神经网络再介绍"><a href="#神经网络再介绍" class="headerlink" title="神经网络再介绍"></a>神经网络再介绍</h2><p>究竟什么是神经网络？</p><h2 id="卷积神经网络CNN"><a href="#卷积神经网络CNN" class="headerlink" title="卷积神经网络CNN"></a>卷积神经网络CNN</h2><p>什么是CNN，它的工作原理是怎样的？</p><h2 id="循环神经网络RNN"><a href="#循环神经网络RNN" class="headerlink" title="循环神经网络RNN"></a>循环神经网络RNN</h2><p>什么是RNN？它的工作原理是怎样的？</p><h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><p>什么是LSTM？它的工作原理是怎样的？</p><h2 id="Autoencoder"><a href="#Autoencoder" class="headerlink" title="Autoencoder"></a>Autoencoder</h2><p>什么是Autoencoder？它的工作原理是怎样的？</p><h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><p>什么是GAN？它的工作原理是怎样的？</p><h2 id="神经网络不是神话"><a href="#神经网络不是神话" class="headerlink" title="神经网络不是神话"></a>神经网络不是神话</h2><p>再进一步认识，到底什么是神经网络。</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>这是神经网络算法有用的关键，一定要搞懂哦。</p><h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><h2 id="什么是迁移学习？它的工作原理是怎样的？"><a href="#什么是迁移学习？它的工作原理是怎样的？" class="headerlink" title="什么是迁移学习？它的工作原理是怎样的？"></a>什么是迁移学习？它的工作原理是怎样的？</h2><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>如何让模型预测更准？如何让算法可以更快地训练出模型？</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>什么是强化学习。它是如何工作的？</p><h2 id="进化学习"><a href="#进化学习" class="headerlink" title="进化学习"></a>进化学习</h2><p>什么是强化学习。它是如何工作的？</p><h1 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h1><h2 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h2><p>它基本上就是DL的代名词了。这是DL开发的一套框架。</p><h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><p>它是DL开发的另一套框架。</p><h2 id="Theano"><a href="#Theano" class="headerlink" title="Theano"></a>Theano</h2><p>它又是一套DL开发的框架。</p><h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><p>它对TensorFlow与Theano进行了封装，现在DL的开发基本就用它了。</p><h2 id="从头做个文章情感倾向判断仪"><a href="#从头做个文章情感倾向判断仪" class="headerlink" title="从头做个文章情感倾向判断仪"></a>从头做个文章情感倾向判断仪</h2><p>这是基于LSTM实现一个对文章情感倾向，进行预判的算法与模型，其中还会用到Attension机制。</p><pre><code>注：乍一看，里面有许多专有的名词，甚至是纯英文的（我不确定该如何翻译，直接引用英文了），感觉好难啊。根据我们的经验，坚持下去，最终您会发现它们也是有迹可循的^_^</code></pre>]]></content>
      
      
      <categories>
          
          <category> 人工智能学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 清单 </tag>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
